# JSON to C++

This program will take either a json file or a URL to a web service and build C++ classes to work with that data. By
default, it will create the serialization linkage for the JsonLink library that is part
of https://github.com/beached/daw_json_link .

* std::optional is used for optional members(those that are not always there or are null in some cases
* std::string is used for strings
* int64_t is used for integral types
* double is used for real types
* bool is used for boolean types
* classes are given the name of their member suffixed with a "_t"
* identifier names are filtered such that C++ keywords, empty id's, or all number id's are prefixed with _json
* Any character in an id that isn't A-Za-z0-9 or _ will be escaped via 0xXXX
* Autogenerated types are their member name suffixed with a _t.

# Running

To output the C++ code to the terminal one just needs to type ```json_to_cpp_bin --in_file jsonfile.json``` or for a url
something like ```json_to_cpp_bin --in_file http://ip.jsontest.com/```

```  
Command line options
Options:
  --help                                print option descriptions
  --in_file arg                         json source file path or url
  --kv_paths arg                        Specify class members that are key 
                                        value pairs
  --use_jsonlink arg (=1)               Use JsonLink serializaion/deserializati
                                        on
  --has_cpp20 arg (=0)                  Enables use of non-type class template 
                                        arguments
  --output_file arg                     output goes to c++ header file.
  --allow_overwrite arg (=0)            Overwrite existing output files
  --hide_null_only arg (=1)             Do not output json entries that are 
                                        only ever null
  --use_string_view arg (=0)            Use std::string_view instead of 
                                        std::string.  Must ensure buffer is 
                                        available after parsing when this is 
                                        used
  --root_object arg (=root_object)      Name of the nameless root object
  --user_agent arg (=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.100 Safari/537.36)
                                        User agent to use when downloading via 
                                        URL
```

# Example

## H2 JSON Data

```
{
    "glossary": {
        "title": "example glossary",
        "GlossDiv": {
            "title": "S",
            "GlossList": {
                "GlossEntry": {
                    "ID": "SGML",
                    "SortAs": "SGML",
                    "GlossTerm": "Standard Generalized Markup Language",
                    "Acronym": "SGML",
                    "Abbrev": "ISO 8879:1986",
                    "GlossDef": {
                        "para": "A meta-markup language, used to create markup languages such as DocBook.",
                        "GlossSeeAlso": ["GML", "XML"]
                    },  
                    "GlossSee": "markup"
                }   
            }   
        }   
    }   
}
```

## Generated C++ Code by calling ```json_to_cpp --in_file name.json```

```c++
#include <daw/json/daw_json_link.h>
#include <string>
#include <tuple>
#include <vector>

struct GlossDef_t {
  std::string para;
  std::vector<std::string> GlossSeeAlso;
}; // GlossDef_t

struct GlossEntry_t {
  std::string ID;
  std::string SortAs;
  std::string GlossTerm;
  std::string Acronym;
  std::string Abbrev;
  GlossDef_t GlossDef;
  std::string GlossSee;
}; // GlossEntry_t

struct GlossList_t {
  GlossEntry_t GlossEntry;
}; // GlossList_t

struct GlossDiv_t {
  std::string title;
  GlossList_t GlossList;
}; // GlossDiv_t

struct glossary_t {
  std::string title;
  GlossDiv_t GlossDiv;
}; // glossary_t

struct root_object_t {
  glossary_t glossary;
}; // root_object_t

namespace daw::json {
  template<>
  struct json_data_contract<GlossDef_t> {
    static constexpr char const mem_para[] = "para";
    static constexpr char const mem_GlossSeeAlso[] = "GlossSeeAlso";
    using type = json_member_list<
      json_string<mem_para>,
      json_array<mem_GlossSeeAlso, std::string, std::vector<std::string>>>;

    static inline auto to_json_data( GlossDef_t const &value ) {
      return std::forward_as_tuple( value.para, value.GlossSeeAlso );
    }
  };
} 
namespace daw::json {
  template<>
  struct json_data_contract<GlossEntry_t> {
    static constexpr char const mem_ID[] = "ID";
    static constexpr char const mem_SortAs[] = "SortAs";
    static constexpr char const mem_GlossTerm[] = "GlossTerm";
    static constexpr char const mem_Acronym[] = "Acronym";
    static constexpr char const mem_Abbrev[] = "Abbrev";
    static constexpr char const mem_GlossDef[] = "GlossDef";
    static constexpr char const mem_GlossSee[] = "GlossSee";
    using type = json_member_list<
      json_string<mem_ID>, json_string<mem_SortAs>, json_string<mem_GlossTerm>,
      json_string<mem_Acronym>, json_string<mem_Abbrev>,
      json_class<mem_GlossDef, GlossDef_t>, json_string<mem_GlossSee>>;

    static inline auto to_json_data( GlossEntry_t const &value ) {
      return std::forward_as_tuple( value.ID, value.SortAs, value.GlossTerm,
                                    value.Acronym, value.Abbrev, value.GlossDef,
                                    value.GlossSee );
    }
  };
} 
namespace daw::json {
  template<>
  struct json_data_contract<GlossList_t> {
    static constexpr char const mem_GlossEntry[] = "GlossEntry";
    using type = json_member_list<json_class<mem_GlossEntry, GlossEntry_t>>;

    static inline auto to_json_data( GlossList_t const &value ) {
      return std::forward_as_tuple( value.GlossEntry );
    }
  };
} 
namespace daw::json {
  template<>
  struct json_data_contract<GlossDiv_t> {
    static constexpr char const mem_title[] = "title";
    static constexpr char const mem_GlossList[] = "GlossList";
    using type = json_member_list<json_string<mem_title>,
                                  json_class<mem_GlossList, GlossList_t>>;

    static inline auto to_json_data( GlossDiv_t const &value ) {
      return std::forward_as_tuple( value.title, value.GlossList );
    }
  };
} 
namespace daw::json {
  template<>
  struct json_data_contract<glossary_t> {
    static constexpr char const mem_title[] = "title";
    static constexpr char const mem_GlossDiv[] = "GlossDiv";
    using type = json_member_list<json_string<mem_title>,
                                  json_class<mem_GlossDiv, GlossDiv_t>>;

    static inline auto to_json_data( glossary_t const &value ) {
      return std::forward_as_tuple( value.title, value.GlossDiv );
    }
  };
} 
namespace daw::json {
  template<>
  struct json_data_contract<root_object_t> {
    static constexpr char const mem_glossary[] = "glossary";
    using type = json_member_list<json_class<mem_glossary, glossary_t>>;

    static inline auto to_json_data( root_object_t const &value ) {
      return std::forward_as_tuple( value.glossary );
    }
  };
}
```
